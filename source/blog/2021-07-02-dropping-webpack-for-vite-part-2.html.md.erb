---
title: Dropping Webpack for Vite Part 2
date: 2021-07-02 19:05
tags:
  - Software engineering
  - JavaScript
  - Netlify
---
My [previous post](/blog/dropping-webpack-for-vite-part-1/) walked through my progress with swapping [Webapck](https://webpack.js.org/) for [Vite](https://vitejs.dev/) using the [Middleman external pipeline](https://middlemanapp.com/advanced/external-pipeline/). I was able to quickly see great performance improvements, reduced dev server and build times and a decent drop in the number of JavaScript dependencies. But there were still some issues and I knew I could improve things. Especially when I discovered [Vite Ruby](https://vite-ruby.netlify.app/).

<!--more-->

What was it that I saw in Vite Ruby that I thought could really help? It was the [DevServerProxy](https://github.com/ElMassimo/vite_ruby/blob/main/vite_ruby/lib/vite_ruby/dev_server_proxy.rb) which inherits from `Rack::Proxy` and relays asset requests to the Vite development server which is exactly what I thought I might need to write myself in order to make Vite work in development mode with no bundling. The best part was this was only a small part of it, with potentially less configuration required, helpers to make it work with Middleman and improved performance with module preloading imports within the bundled JavaScript assets.

Vite Ruby is the core library but there was also a [Padrino Integration](https://vite-ruby.netlify.app/guide/padrino.html) which looked like it would help with Middleman and bring with it tag helpers, hot module reloading and smart output with module preloading as mentioned above. The [Middleman helper methods](https://middlemanapp.com/basics/helper-methods/) are all build upon [Padrino helpers](http://padrinorb.com/guides/application-helpers/overview/) so it looked like a good bet that this integration would work well.

## Installation

The first thing to do is add the new Gems

<% highlight code: "ruby" do %>
gem "vite_padrino"
gem "vite_ruby"
<% end %>

and then `bundle install`. Then run the Vite Ruby installer `bundle exec vite install` and sets up all the necessary configuration as well as creating a demo JavaScript file.

The next thing to do was to get Middleman using the Vite Ruby DevServerProxy and the Padrino tag helpers

<% highlight code: "ruby" do %>
require "vite_ruby"
require "vite_padrino/tag_helpers"

...

configure :development do
  use ViteRuby::DevServerProxy, ssl_verify_none: true
end
helpers VitePadrino::TagHelpers
<% end %>

## Configuration

I also had to swap all of my instances of `javascript_include_tag`, `stylesheet_link_tag` and `asset_path` with `vite_javascript_tag`, `vite_stylesheet_tag` and `vite_asset_path` respectively. Also, to make the hot module reloading work you simply have to add `<%= vite_client_tag %>` somewhere so that it will be picked up on all pages.

Vite Ruby is similar in approach to [Webpacker](https://edgeguides.rubyonrails.org/webpacker.html) with convention over configuration and all entry point assets are placed in `frontend/entrypoints`. You can read in my [previous post](/blog/dropping-webpack-for-vite-part-1/) how I changed the configuration of my assets to use glob imports from within the asset files themselves rather than using Webpack so I performed the same setup for this. Therefore it was pretty simple to move my assets to the new `frontend/entrypoints` folder and all the other required assets under the `frontend` folder.

Vite Ruby automatically creates a `config/vite.json` file as part of the installer and mine used the defaults settings except for adding `"watchAdditionalPaths": \["components/\*\*/*"]` so the dev server would automatically reload the page when I make changes in my assets in the components folder which is where I have my view components.

<% highlight code: "json" do %>
{
  "all": {
    "publicDir": "source",
    "sourceCodeDir": "frontend",
    "watchAdditionalPaths": ["components/**/*"]
  },
  "development": {
    "autoBuild": true,
    "publicOutputDir": "vite-dev",
    "port": 3036
  },
  "test": {
    "autoBuild": true,
    "publicOutputDir": "vite-test"
  }
}
<% end %>

My `vite.config.js` is stripped down compared to the last post because of the Vite Ruby conventions so I don't need the input and output part of the configuration

<% highlight code: "javascript" do %>
import esbuild from "rollup-plugin-esbuild"
import FullReload from 'vite-plugin-full-reload'
import { defineConfig } from "vite"
import RubyPlugin from "vite-plugin-ruby"

export default defineConfig({
  build: {
    brotliSize: false,
    emptyOutDir: true,
    minify: "esbuild",
    rollupOptions: {
      output: {
        format: "es",
        manualChunks: {
          game_vendor: \["crypto-es"]
        }
      }
    }
  },
  plugins: \[
    esbuild({
      target: [
        "chrome64",
        "edge79",
        "firefox62",
        "safari11.1",
      ]
    }),
    FullReload(["source/**/*"], { delay: 1000 }),
    RubyPlugin(),
  ]
})
<% end %>

The main difference you'll see from the last post is the addition of `vite-plugin-ruby` which I've added and setup to reload the page on every file change within the `source` folder which is really handy.

## Drop Webpack

With Vite Ruby setup I could remove all the Webpack configuration like I demonstrated in the previous post. I could also remove the Middleman external pipeline from ```config.rb``` as well as ```config[:css_dir]``` and ```config[:js_dir]``` and finally ```activate :asset_hash``` because all the hashing was now handled by Vite. Removing ```activate :asset_hash``` eliminated the bug I had in the previous post with the asset hashed path which was another bonus.

I now have to run 2 commands to get things working in development
* bin/vite dev
* bundle exec middleman serve

which normally can be a bit of a pain but I use 