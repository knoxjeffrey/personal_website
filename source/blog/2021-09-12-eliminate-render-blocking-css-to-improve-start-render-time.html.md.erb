---
title: Eliminate render blocking CSS to improve start render time
date: 2021-09-12 10:27
tags:
  - Web performance
---
Although this website scores a perfect 100 in [PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights), that doesn't mean things can't be improved. First time visitors on slower connections used to see nothing for over 1.6s before finally seeing a fully rendered view. I'd like to explain how I rendered the view more progressively with inline and async CSS to improve start render time by 0.5s.

<!--more-->

The best place to begin is with a sample run of my homepage on [WebPageTest](https://www.webpagetest.org/) on an Emulated Motorola G (gen 4) device using a Chrome browser with a 3G fast connection.

![](webpagetest.jpg)

From this you can see that there are 2 render blocking CSS assets, marked by white x's on an orange background to the left of the asset name. This means that there will be absolutely nothing on the screen until those assets have finished being downloaded and parsed. You may also notice that, even with this done, there is still a period of time before start render occurs which is represented with the final vertical green lime. Just before this, there is an intensive block of purple in the browser main thread which is taken up with layout and paint.

You can see the effects of this in the following filmstrip.

![](webpagetest_screenshot.jpg)

The screen is totally blank until 1.7s, at which point there is a fully rendered view. Not a very progressive load I'm sure you'll agree!

## The ideal solution

My preference was to have at least something on the screen very soon after the page content has been fetched at around 1s. Creating this impression in the users mind that at least something is happening is very important to keep the user hanging around. Too much time with a blank screen and they'll quickly abandon the visit and move onto something else.

Therefore, my plan was to have the background colour visible as well as the navigation component at the top of the screen before finally displaying the rest of the content.

In order to make this happen, I needed to alter my CSS so that I inlined the portion of CSS required for the background and navigation and then load the rest of the CSS asynchronously. Having a minimal area of the screen rendering straight away meant that I wouldn't have to inline too much CSS. It's a bit of a balancing act but I try to keep at 5kb's worth or under (this value is the total before any compression with gzip or brotli) of inlined CSS. You'll take the pain of downloading that inlined CSS on every page load because it can't be cached with the rest of your assets so it's best to keep it as minimal as possible.

## My approach

I fired up my dev server and loaded up the home page. Next, I open the Chrome Dev tools and navigate to the Network tab. Finally, I right click on each of my CSS files and choose to block the request URL. Then when I reload the page I have a totally unstyled page and this makes it easy to then start adding the inlined styles to get to a point where I only added the bare minimum to achieve the initial load I was after.

The next part is going to vary depending on your asset bundling setup but I'll show what I did and hopefully that will give you some pointers. I use [Vite](https://vitejs.dev/) under the hood but with my site being Ruby based I used [Vite Ruby](https://vite-ruby.netlify.app/) to add some additional helper methods. If you like, you can read more about this setup [here](/blog/dropping-webpack-for-vite-part-2/).