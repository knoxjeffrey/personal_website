---
title: Building a custom data layer for logging web performance metrics
date: 2021-08-22 21:46
tags:
  - Software engineering
  - Web performance
  - JavaScript
---
I've started using [Perfume.js](https://zizzamia.github.io/perfume/) on this site to capture web performance metrics including [Core Web Vitals](https://web.dev/vitals/). As part of this, I wanted to create a flexible logging tool that would help me send this data to my [Supabase](https://supabase.io/) backend but also handle logging any other performance data in the future, and heck, handle anything I might want to log!

<!--more-->

My solution is inspired by the idea of a dataLayer as used with Google Tag Manager. It's an array (with some additional functionality in my case) that can have objects with an event name pushed to it from anywhere in the front-end. Those event objects can then be handled on an individual basis, such as forwarding on performance events to supabase in this case. I'm calling my creation pushr!

## Array proxy

I mentioned that the pushr array will have a little bit of additional functionality. Instead of constantly polling the array to check for new event, I'd like for the array to emit a custom event whenever new data is pushed to the array. Then I can create an event listener to handle the data passed with that event.

To achieve this I can use a [Proxy object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) which can intercept and redefine fundamental operations for that object. The proxy takes 2 arguments:

1. A target which is the object I want to proxy, an array in my case.
2. A handler which is an object that defines which operations will be intercepted and how to redefine those intercepted operations.

I'm going to provide an implementation for the `set()` handler in the proxy which is a trap for setting a property value. In there I'll define a new custom event called `pushrset` which will contain the data that has just been set on the array and then emit the event.

So, to start with I'll create a new directory in my javascript folder called `pushr` and add a file called `index.js`.

<% highlight code: "javascript" do %>
export const pushr = (() => {
  
  const _pushrHandler = {
    set: (target, prop, value) => {
      if (prop !== "length") {
        const pushEvent = new CustomEvent("pushrset", { detail: value })
        window.dispatchEvent(pushEvent)
      }
      return Reflect.set(target, prop, value)
    }
  }

  const init = () => {
    window.pushr = new Proxy([], _pushrHandler)
  }

  return { init }
})()
<% end %>

If I now import `pushr` into my main JS file and ensure I call `pushr.init()` before my other code then I will have the Proxy object available when I call `window.pushr` from the dev tools console. As it is also called before all of my other JavaScript, I can now make a test by inserting `window.pushr.push({ event: "test" })` anywhere in my other JavaScript files.

## Listening for pushr

