---
title: Store Netlify build data in Supabase
date: 2021-07-22 20:19
tags:
  - Software engineering
  - Netlify
  - Ruby
  - JavaScript
---
I've found it useful in the past to keep a close eye on build times because it can be easy to introduce code over time that drives the build time up. By the time you notice that this is becoming a pain point, it's very difficult to track down the offending pieces of code to resolve the issue.

<!--more-->

[Netlify](https://www.netlify.com/) does keep a record of the builds in their UI but it's difficult and slow to manually click through and figure out any kind of pattern. There's also the [Netlify API](https://open-api.netlify.com/) which you could query directly to look at records over time but again this can be tricky because you can't drill down in the API queries to search by date, build time, etc.

What I would like to do is store the build data at the end of each build and then I can build my own graphical interface to query and drill down into the data as I please. This post will focus on the first piece of the puzzle, storing the data but I plan on following up soon with another post using [d3.js](https://d3js.org/) to visualise the data.

## The tech stack

This post is going to pull together several features of Netlify, [Supabase](https://supabase.io/) and [Jake.js](https://jakejs.com/docs-page.html#item-advanced-usage-programmatic-tasks) so there'll be plenty to get stuck into:

* Netlify [](https://www.netlify.com/products/build/plugins/)[event triggered](https://docs.netlify.com/functions/trigger-on-events) [Background Functions](https://docs.netlify.com/functions/background-functions/)
* The Supabase [API](https://supabase.io/docs/guides/api) called within the Background Function to push the build data to the Supabase database
* More info about working with Supabase in local development including adding [pgAdmin](https://www.pgadmin.org/) to the [Docker](https://www.docker.com/) container as well as pulling the schema and data down from Supabase production to local and vice-versa using Jake.js tasks.
* Task to seed the database

Time to get started!

## Netlify event triggered Background Function

For my first attempt at getting the build data, I created a build plugin that fetched the deploy id on a successful build, sent that to my Netlify Background Function, used the Netlify API to get the build data associated with that deploy id and then posted the data to Supabase. Then [this article about event triggered functions](https://www.netlify.com/blog/2021/07/21/how-to-use-event-triggered-netlify-functions/) popped up in my [Twitter](https://twitter.com/jeff_r_knox) feed and I could instantly see how it could simplify my code. I was able to drop the build plugin and the API connection and simply create a Netlify Background Function called `deploy-succeeded-background.js`.

The naming is important to make this work. `deploy-succeeded` means the function will be triggered automatically when my deploy is successful. An added bonus of this is that external requests to event functions are blocked because Netlify generates a JSON web signature (JWS) for each event triggered by their platform, and verifies that the signature is correct before invoking the associated event function. This means that anyone trying to spam my function with duff data that could be POSTed to my database will be automatically blocked without me having to do anything. Amazing!

The `-background` added to the end of the Netlify Function automatically makes it a Background Function. A question you may be asking is, why a background function and not a normal function? The main reason is that retries are built into Background Functions meaning if the first attempt fails, the system retries on 2 more occasions which makes my logging more resilient. A final point is that this data is purely for my logging purposes and I'm in no hurry to get the info back to a user for example so I'm fine with the function sitting in a queue for a short while.

For the longer term, one thing I would like to investigate further with Background Functions is how to identify that the function has failed on the 3rd and final attempt as I'd like at that point to be logging the fail information, reporting to Slack, etc for later diagnosis.

Enough chat, lets see some code! Here's the function code needed to set everything up without the final part needed to connect to Supabase:

<% highlight code: "javascript" do %>
const buildContext = (branch, context) => {
  if (context === "production") return context
  return (branch.startsWith("cms/") ? "cms" : context)
}

export async function handler(event, _context) {
  const payload = JSON.parse(event.body).payload
  const { id, branch, context, deploy_time, created_at } = payload

  const dataToInsert = {
    deploy_id: id,
    branch,
    context: buildContext(branch, context),
    deploy_time,
    created_at
  }
  console.log(dataToInsert)
}
<% end %>

Everything I need is in the `payload` object automatically sent by Netlify event and the only additional thing I'm adding is a function to provide more detail to the context of the deploy. By default, Netlify will have contexts of `production` and `deploy-preview` but I'd like to also identify which deploys are created from Netlify CMS which I use for my blog posts so those are easy to pull out in my data visualisation when I get to that stage. Those branch names will always begin with `cms/` so the `buildContext` can easily perform this for me. I also need to change the key `id` to be `deploy_id` otherwise that would clash with the default `id` field in the Supabase DB table I will create to store the build data.

If I now push this code to my PR, all being well my Background Function should automatically be triggered and I can check this in the Netlify UI. From within the screen with all of the deploy data such as logs, etc, there is a link to the `Deployed Functions` near the top. If you click on that you can see all of your functions on that deploy and then click the `deploy-succeeded-background` one. All being well, you should see the console logged info from the function code above. Excellent, we're ready to send that to Supabase now!

## Supabase

You are going to need an account setup on [Supabase](https://supabase.io/) at this point. You can also follow along with this [Netlify blog post](https://www.netlify.com/blog/2021/06/28/saving-data-to-supabase-and-getting-it-back-again/) in the \`Creating a database and your first table\` section. The production setup has a nice UI for creating the database and table whereas this isn't yet available in local development yet. Therefore what I plan on doing is creating the schema in production and then dump it to my local dev environment to experiment with posting data to the DB rather then having to send the data to production for testing purposes. This is something that is worth getting setup now because we don't want to be posting test data to production further down the line and messing with data integrity.

### DB fields 

Click the button to create a new table and I'm calling it \`netlify_deploy_data\` and it will include a primary key called \`id\` and type \`int8\`. Then add the following fields:

1. deploy_id - *varchar*
2. branch *\- varchar*
3. context *\- varchar*
4. deploy_time *\- int2*
5. created_at *\- timestampz - default NULL - do not allow nullable*