---
title: Store Netlify build data in Supabase
date: 2021-07-22 20:19
tags:
  - Software engineering
  - Netlify
  - Ruby
  - JavaScript
---
I've found it useful in the past to keep a close eye on build times because it can be easy to introduce code over time that drives the build time up. By the time you notice that this is becoming a pain point, it's very difficult to track down the offending pieces of code to resolve the issue.

<!--more-->

[Netlify](https://www.netlify.com/) does keep a record of the builds in their UI but it's difficult and slow to manually click through and figure out any kind of pattern. There's also the [Netlify API](https://open-api.netlify.com/) which you could query directly to look at records over time but again this can be tricky because you can't drill down in the API queries to search by date, build time, etc.

What I would like to do is store the build data at the end of each build and then I can build my own graphical interface to query and drill down into the data as I please. This post will focus on the first piece of the puzzle, storing the data but I plan on following up soon with another post using [d3.js](https://d3js.org/) to visualise the data.

## The tech stack

This post is going to pull together several features of Netlify, [Supabase](https://supabase.io/) and [Jake.js](https://jakejs.com/docs-page.html#item-advanced-usage-programmatic-tasks) so there'll be plenty to get stuck into:

* Netlify [](https://www.netlify.com/products/build/plugins/)[event triggered](https://docs.netlify.com/functions/trigger-on-events) [Background Functions](https://docs.netlify.com/functions/background-functions/)
* The Supabase [API](https://supabase.io/docs/guides/api) called within the Background Function to push the build data to the Supabase database
* More info about working with Supabase in local development including adding [pgAdmin](https://www.pgadmin.org/) to the [Docker](https://www.docker.com/) container as well as pulling the schema and data down from Supabase production to local and vice-versa using Jake.js tasks.
* Task to seed the database

Time to get started!

## Netlify event triggered Background Function

For my first attempt at getting the build data I created a build plugin that fetched the deploy id on a successful build, sent that to my Netlify Background Function, used the Netlify API to get the build data associated with that deploy id and then posted the data to Supabase. Then [this article about event triggered functions](https://www.netlify.com/blog/2021/07/21/how-to-use-event-triggered-netlify-functions/) popped up in my [Twitter](https://twitter.com/jeff_r_knox) feed and I could instantly see how it could simplify my code. I was able to drop the build plugin and the API connection and simply create a Netlify Background Function called `deploy-succeeded-background`.

The naming is important to make this work. `deploy-succeeded` means the function will be triggered automatically when my deploy is successful. An added bonus of this is that external requests to event functions are blocked because Netlify generates a JSON web signature (JWS) for each event triggered by their platform, and verifies that the signature is correct before invoking the associated event function. This means that anyone trying to spam my function with duff data that could be POSTed to my database will be blocked without me having to do anything. Amazing!

A question you may be asking is, why a background function and not a normal function? A large benefit
for my use case is that a Background Function will return an immediate 202 client response on successful
invocation and then continue running in the background until it completes. This keeps my builds super
speedy, with the Build Plugin completing in well under 500ms. Additionally, retries are built into
Background Functions meaning if the first attempt fails, the system retries on 2 more occassions which
makes my logging more resilient. A final point is that this data is purely for my logging purposes and
I'm in no hurry to get the info back to a user for example so I'm happy for the function to sit in
a queue for a short while.

For the longer term, one thing I would like to investigate further with Background Functions is how to
identify that the function has failed on the 3rd and final attempt as I'd like at that point to be
logging the fail information, reporting to Slack, etc for later diagnosis.