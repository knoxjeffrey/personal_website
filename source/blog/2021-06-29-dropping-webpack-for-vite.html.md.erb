---
title: Dropping Webpack for Vite
date: 2021-06-29 22:23
tags:
  - Software engineering
  - JavaScript
---
I have been using the [Middleman external pipeline](https://middlemanapp.com/advanced/external-pipeline/) with [Webpack](https://webpack.js.org/) to bundle my JavaScript and SCSS files and this approach has been working well after I worked my way through all of the complexities of the initial Webpack configuration. But with so many bundlers available at the moment I thought it was time to see how things could be improved.

<!--more-->

What I was hoping for was a simpler configuration and to reduce the number of dependencies installed so there is less effort required to patch them. A faster local dev server would also be a benefit, as would a faster build time. This is how I started the journey

<% table caption: "" do %>
  <% table_body do %>
    <tr>
      <th>Dependencies</th>
      <td>1225</td>
    </tr>
    <tr>
      <th>Dev server time</th>
      <td>8.26s</td>
    </tr>
    <tr>
      <th>Netlify build time</th>
      <td>21.05s</td>
    </tr>
    <tr>
      <th>Netlify cache size</th>
      <td>234.9MB</td>
    </tr>
    <tr>
      <th>Javascript files</th>
      <td></td>
    </tr>
    <tr>
      <th>main.js</th>
      <td>24.5kb</td>
    </tr>
    <tr>
      <th>components.js</th>
      <td>14.7kb</td>
    </tr>
    <tr>
      <th>game.js</th>
      <td>15.6kb</td>
    </tr>
  <% end %>
<% end %>

To clarify some points in the table, firstly, the dev server time is the time for both Middleman and Webpack to run and the site is available to view. The build time is not the full Netlify deploy time which includes downloading and extracting the cache, the Middleman build plus asset bundling and finally uploading the site. In this case, the time is purely for the Middleman build and asset bundling as it's a more consistent and relevant measure. 1225 is a crazy number of node modules given that I have a grand total of 24 devDependencies and dependencies!

## Webpack out, Vite in

After doing some research I decided that [Vite](https://vitejs.dev/) looked like a great option with no bundling required for local dev work and [Rollup](https://rollupjs.org/guide/en/) for production bundling along with [esbuild](https://esbuild.github.io/) for transpilation and minification.

If you have time it would be worth reading [this post](/blog/building-view-components-in-middleman/) on how I'm using View Components in my Middleman setup as it gives some context around my current Webpack setup.

So to start with I needed to install vite with ```yarn add vite --dev``` and then change my scripts in ```package.json`:

<% highlight code: "json" do %>
"scripts": {
  "dev": "vite dev",
  "build": "vite build"
}
<% end %>

and my external pipeline shouldn't need much changed in ```config.rb```

<% highlight code: "ruby" do %>
activate :external_pipeline,
         name: :vite,
         command: build? ? "yarn run build" : "yarn run dev",
         source: ".tmp/dist",
         latency: 1
<% end %>

Or will it? At this point I noticed the ```source: ".tmp/dist"``` part of the setup and it reminded me that for the external pipeline to work it needs the bundler to output files in dev to a temp folder. This meant that the no bundle approach of Vite in dev wouldn't work.

As a temporary measure I changed the ```dev``` script

<% highlight code: "json" do %>
"scripts": {
  "dev": "vite build --watch",
  "build": "vite build"
}
<% end %>

so Vite would bundle my JS and CSS but also rebundle and reload the page when I changed JS or CSS in development. I had an idea to work on at the end of this to write some Rack middleware that could intercept requests to JS and CSS files and send them to the Vite dev server so that the original technique would work but for now I just wanted to get it all working and maybe this would be faster anyway in comparison to Webpack.

## PostCSS
Vite also works with PostCSS out of the box. I was already using PostCSS with this ```postcss.config.js``` config

<% highlight code: "javascript" do %>
module.exports = {
  plugins: [
    require("postcss-preset-env")({
      browsers: "last 2 versions",
    })
  ]
}
<% end %>

After doing a bit more reading about PostCSS I realise that there were many plugins to extend the functionality and allow it to do much of what I would be needing from SCSS.

My SCSS files at this point were really just pure CSS anyway with some use of ```@import``` so it was pretty easy to make the switch and I added some new dependencies ```yarn add postcss-import postcss-import-ext-glob --dev``` and updated my config file

<% highlight code: "javascript" do %>
module.exports = {
  plugins: [
    require("postcss-import-ext-glob"),
    require("postcss-import"),
    require("postcss-preset-env")({
      browsers: "last 2 versions",
    })
  ]
}
<% end %>

The ```postcss-import``` is pretty self explanatory for SASS users but I added ```postcss-import-ext-glob``` to allow me to use a glob syntax to import all of the CSS files in my components directory. The ```components_css.css``` file is pretty simple

<% highlight code: "css" do %>
@import-glob "../../../components/**/*.css" 
<% end %>

I needed to do something similar to import all of my JS files from the component directory in a ```components.js``` file

<% highlight code: "javascript" do %>
const modules = import.meta.globEager("../../components/**/*.js")
<% end %>

If you've read my view components blog post you'll see that I was previously doing these glob imports within in my ```webpack.config.js``` file.

## Vite config
The final piece of the puzzle was the ```vite.config.js``` file but first I installed ```rollup-plugin-esbuild``` so esbuild is used in the build rather than Terser.

<% highlight code: "javascript" do %>
import esbuild from "rollup-plugin-esbuild"

export default ({ command, mode }) => {
  let minifySetting

  if (mode === "development") {
    minifySetting = false  
  } else {
    minifySetting = "esbuild" 
  }

  return {
    build: {
      brotliSize: false,
      emptyOutDir: true,
      minify: minifySetting,
      outDir: ".tmp/dist/assets",
      rollupOptions: {
        input: {
          "components": "./source/assets/javascripts/components.js",
          "main": "./source/assets/javascripts/main.js",
          "game": "./source/assets/javascripts/game/game.js",
          "commento_css": "./source/assets/stylesheets/commento.css",
          "components_css": "./source/assets/stylesheets/components.css",
          "game_css": "./source/assets/stylesheets/game.css",
          "main_css": "./source/assets/stylesheets/main.css",
        },
        output: {
          assetFileNames: "[name].css",
          chunkFileNames: "[name].js",
          entryFileNames: "[name].js",
          format: "es"
        },
        plugins: [
          esbuild({
            target: "es2015"
          })
        ],
      },
      sourcemap: true,
      manifest: true
    },
    server: {
      port: "3333"
    }
  }
}
<% end %>

At the top of the file I check if the mode is currently in development so I can decide whether or not to minify my JavaScript and if it's in production then I need to state that I was to use esbuild for transpiling and minifying plus add a plugins section for the build

<% highlight code: "javascript" do %>
plugins: [
  esbuild({
    target: "es2015"
  })
],
<% end %>

Turning off ```brotliSize``` speeds up the build by not displaying the compressed size of file in the build output. ```emptyOutDir``` means the output directory defined in ```outDir``` if cleared out when the build starts. 

```rollupOptions.input``` is straight forward and gives a name for the bundled assets and a path. For the ```output```, ```assetFileNames``` is the output of the non JS files which in my case will just be for CSS. The ```chunkFileNames``` is the output config for chunks which are common modules shared between multiple ```input``` files that get extracted so the same code isn't repeated across multiple bundled files. The ```entryFileNames``` is simply the config for how to output the JS files set in ```input```.

I've set the ```format``` as ```es``` to output in es format, turned on sourcemaps and manifest files as well as setting the port for the Vite server.